{"version":3,"sources":["../../../../../node_modules/tslib/tslib.es6.js","ng://@libertyware/ngx-form-builder/models/dynamic-form-group-config.ts","ng://@libertyware/ngx-form-builder/validators/forever-invalid.validator.ts","ng://@libertyware/ngx-form-builder/utils/dynamic-form-control.ts","ng://@libertyware/ngx-form-builder/utils/dynamic-form-group.ts","ng://@libertyware/ngx-form-builder/utils/dynamic-form-builder.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","__read","o","m","r","ar","error","isDynamicFormGroupConfig","options","isNullOrUndefined","isLegacyOrOpts","isAbstractControlOptions","validators","asyncValidators","updateOn","foreverInvalid","c","valid","DynamicFormControl","fieldDefinition","_this","_super","data","validationFunctions","validationDefinitions","tslib_1.__extends","defineProperty","parent","object","metaData","MetadataKeys","HINT","DISPLAY_NAME","ControlName","PLACEHOLDER","key","Reflect","getMetadata","formModel","controls","keys","find","name","RADIO_OPTIONS","TEXTAREA_OPTIONS","FormControl","DynamicFormGroup","factoryModel","fields","validatorOrOpts","asyncValidator","nativeValidateErrors","BehaviorSubject","customValidateErrors","formErrors","objectChange","Subject","FormControlClass","_object","_externalErrors","_validatorOptions","_fb","FormBuilder","formFields","onlyFields","_formGen","getFormFieldsOptions","getFormGenData","externalErrors","validate","validatorOptions","getObject","setObject","validateAsync","undefined","cloneDeep","_a","validationErrors","transformValidationErrors","allErrors","mergeErrors","markAsInvalidForExternalErrors","setCustomErrors","usedForeverInvalid","filter","get","removeControl","addControl","updateValueAndValidity","onlySelf","emitEvent","collectErrors","control","isRoot","errors","entries","reduce","acc","_c","childControl","childErrors","_b","validateAllFormFields","forEach","field","markAsTouched","FormArray","resetValidateAllFormFields","setErrors","markAsUntouched","markAsPristine","classToClass","ignoreDecorators","plainToClass","cls","plain","setExternalErrorsAsync","setExternalErrors","getExternalErrors","clearExternalErrors","clearExternalErrorsAsync","setValidatorOptionsAsync","setValidatorOptions","getValidatorOptions","newFields","customErrors","constraints","property","indexOf","children","clonedExternalErrors","mergeWith","objValue","srcValue","isArray","objItem","concat","externalError","objectArray","formArray","isFormGroup","firstFormGroup","formControl","removeAt","dynamicFormGroup_1","setParent","classValidators","getClassValidators","formGroup_1","group","ctrlKey","valueChanges","subscribe","controlValue","newFormControl","validator","newObject","setValue","FormGroup","allValidationMetadatas","getFromContainer","MetadataStorage","getTargetValidationMetadatas","validationGroupMetadatas","groups","formGroupFields","Validator","fieldName","conditionalValidations","validationMetadata","isPropertyValidatorOfType","ValidationKeys","conditional","type","allNestedValidations","nested","nestedGroupValidations","validationFunction","index","propertyName","typeKey","ValidationTypes","checkWithAllNestedValidations","isNestedValidate","nestedValidate","createNestedValidate","setFieldData","isCustomValidate","customValidation","createCustomValidation","isDynamicValidate","dynamicValidate","createDynamicValidate","objectToValidate","getIsValidResult","getValidateErrors","isValid","validateValueByMetadata","setObjectValueAndGetValidationErrors","validateErrors","getAllErrors","nestedValidations","isNotPropertyValidation","custom","validationMetadataType","dataToValidate","validateSync","errorType","DynamicFormBuilder","FormGroupClass","controlsConfig","getFormFields","map","rev","current","newControlsConfig","extra","customValidatorOptions","validationError","target","createEmptyObject","candidate","tslib_1.__assign","canCreateArray","array","newControlsConfigItem","formGroup","dynamicFormGroup","modified"],"mappings":";;;;;;;;;;;;;;;AAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAG5E,IAAIK,EAAW,WAQlB,OAPAA,EAAWZ,OAAOa,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIZ,KADTW,EAAIG,UAAUF,GACOhB,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,KAAIU,EAAEV,GAAKW,EAAEX,IAE9E,OAAOU,IAEKO,MAAMb,KAAMU,YA8BzB,SAASI,EAAUC,EAASC,EAAYC,EAAGC,GAC9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOL,OAAS,IAAIN,GAAE,SAAUG,GAAWA,EAAQQ,EAAOL,UAAWO,KAAKR,EAAWK,GACnIH,GAAMN,EAAYA,EAAUL,MAAME,EAASC,GAAc,KAAKS,WAI/D,SAASM,EAAYhB,EAASiB,GACjC,IAAsGC,EAAGC,EAAG5B,EAAG6B,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPhC,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOiC,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEV,KAAMgB,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAO7C,OAAUmC,EACvJ,SAASM,EAAKhC,GAAK,OAAO,SAAUqC,GAAK,OACzC,SAAcC,GACV,GAAId,EAAG,MAAM,IAAIe,UAAU,mCAC3B,KAAOZ,GAAG,IACN,GAAIH,EAAI,EAAGC,IAAM5B,EAAY,EAARyC,EAAG,GAASb,EAAU,OAAIa,EAAG,GAAKb,EAAS,SAAO5B,EAAI4B,EAAU,SAAM5B,EAAEM,KAAKsB,GAAI,GAAKA,EAAET,SAAWnB,EAAIA,EAAEM,KAAKsB,EAAGa,EAAG,KAAKlB,KAAM,OAAOvB,EAE3J,OADI4B,EAAI,EAAG5B,IAAGyC,EAAK,CAAS,EAARA,EAAG,GAAQzC,EAAEiB,QACzBwB,EAAG,IACP,KAAK,EAAG,KAAK,EAAGzC,EAAIyC,EAAI,MACxB,KAAK,EAAc,OAAXX,EAAEC,QAAgB,CAAEd,MAAOwB,EAAG,GAAIlB,MAAM,GAChD,KAAK,EAAGO,EAAEC,QAASH,EAAIa,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKX,EAAEI,IAAIS,MAAOb,EAAEG,KAAKU,MAAO,SACxC,QACI,KAAkB3C,GAAZA,EAAI8B,EAAEG,MAAY5B,OAAS,GAAKL,EAAEA,EAAEK,OAAS,MAAkB,IAAVoC,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEX,EAAI,EAAG,SACjG,GAAc,IAAVW,EAAG,MAAczC,GAAMyC,EAAG,GAAKzC,EAAE,IAAMyC,EAAG,GAAKzC,EAAE,IAAM,CAAE8B,EAAEC,MAAQU,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYX,EAAEC,MAAQ/B,EAAE,GAAI,CAAE8B,EAAEC,MAAQ/B,EAAE,GAAIA,EAAIyC,EAAI,MAC7D,GAAIzC,GAAK8B,EAAEC,MAAQ/B,EAAE,GAAI,CAAE8B,EAAEC,MAAQ/B,EAAE,GAAI8B,EAAEI,IAAIU,KAAKH,GAAK,MACvDzC,EAAE,IAAI8B,EAAEI,IAAIS,MAChBb,EAAEG,KAAKU,MAAO,SAEtBF,EAAKf,EAAKpB,KAAKG,EAASqB,GAC1B,MAAOV,GAAKqB,EAAK,CAAC,EAAGrB,GAAIQ,EAAI,EAAI,QAAWD,EAAI3B,EAAI,EACtD,GAAY,EAARyC,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAExB,MAAOwB,EAAG,GAAKA,EAAG,QAAK,EAAQlB,MAAM,GArB9BL,CAAK,CAACf,EAAGqC,MAwCtD,SAASK,EAAOC,EAAG3C,GACtB,IAAI4C,EAAsB,mBAAXT,QAAyBQ,EAAER,OAAOC,UACjD,IAAKQ,EAAG,OAAOD,EACf,IAAmBE,EAAY5B,EAA3BlB,EAAI6C,EAAEzC,KAAKwC,GAAOG,EAAK,GAC3B,IACI,WAAc,IAAN9C,GAAgBA,KAAM,MAAQ6C,EAAI9C,EAAEiB,QAAQI,MAAM0B,EAAGL,KAAKI,EAAE/B,OAExE,MAAOiC,GAAS9B,EAAI,CAAE8B,MAAOA,GACjC,QACQ,IACQF,IAAMA,EAAEzB,OAASwB,EAAI7C,EAAU,SAAI6C,EAAEzC,KAAKJ,GAE1D,QAAkB,GAAIkB,EAAG,MAAMA,EAAE8B,OAE7B,OAAOD,WCzHKE,EAAyBC,GACvC,OAAOA,IAAYC,EAAAA,kBAAkBD,EAAgC,wBAEvE,SAAgBE,EAAeF,GAC7B,OAAOA,KAAaC,EAAAA,kBAAkBD,EAAmB,aAAOC,EAAAA,kBAAkBD,EAAwB,iBAE5G,SAAgBG,EAAyBH,GACvC,OACEA,KACEC,EAAAA,kBAAkBD,EAAQI,cACzBH,EAAAA,kBAAkBD,EAAQK,mBAC1BJ,EAAAA,kBAAkBD,EAAQM,oBCrBjBC,EAAeC,GAC7B,MAAO,CACLD,eAAgB,CACdE,OAAO,IAIb,kBCCE,SAAAC,EAAYC,GAAZ,IAAAC,EACEC,EAAA3D,KAAAZ,KAAMqE,EAAgBG,KAAMH,EAAgBI,sBAAoBzE,YAEhEsE,EAAKI,sBAAwBL,EAAgBK,wBAoCjD,OA1CwCC,EAAAA,EAAAA,GAStCnF,OAAAoF,eAAYR,EAAAlE,UAAA,YAAS,KAArB,WACE,OAAQF,KAAK6E,OAAiCC,wCAIhDtF,OAAAoF,eAAIR,EAAAlE,UAAA,OAAI,KAAR,WACE,OAAOF,KAAK+E,SAASC,EAAAA,aAAaC,uCAGpCzF,OAAAoF,eAAIR,EAAAlE,UAAA,eAAY,KAAhB,WACE,OAAOF,KAAK+E,SAASC,EAAAA,aAAaE,eAAiBlF,KAAKmF,6CAG1D3F,OAAAoF,eAAIR,EAAAlE,UAAA,cAAW,KAAf,WACE,OAAOF,KAAK+E,SAASC,EAAAA,aAAaI,8CAG5BhB,EAAAlE,UAAA6E,SAAR,SAAiBM,GACf,OAAOC,QAAQC,YAAYF,EAAKrF,KAAKwF,UAAWxF,KAAKmF,cAGvD3F,OAAAoF,eAAIR,EAAAlE,UAAA,cAAW,KAAf,WAAA,IAAAoE,EAAAtE,KACQyF,EAAgBzF,KAAK6E,OAAOY,SAClC,OAAOjG,OAAOkG,KAAKD,GAAUE,MAAK,SAAAC,GAAQ,OAAAtB,IAASmB,EAASG,uCAG9DpG,OAAAoF,eAAIR,EAAAlE,UAAA,eAAY,KAAhB,WACE,OAAOF,KAAK+E,SAASC,EAAAA,aAAaa,gBAAkB,oCAGtDrG,OAAAoF,eAAIR,EAAAlE,UAAA,kBAAe,KAAnB,WACE,OAAOF,KAAK+E,SAASC,EAAAA,aAAac,mDAEtC1B,GA1CwC2B,EAAAA,2BCwDtC,SAAAC,EACSC,EACAC,EACPC,EAKAC,GARF,IAAA9B,EAUEC,EAAA3D,KAAAZ,KAAM,GAAImG,EAAiBC,IAAepG,YATnCsE,EAAA2B,aAAAA,EACA3B,EAAA4B,OAAAA,EAfF5B,EAAA+B,qBAAuB,IAAIC,EAAAA,gBAA4B,IACvDhC,EAAAiC,qBAAuB,IAAID,EAAAA,gBAAuC,IAClEhC,EAAAkC,WAA2C,KAE3ClC,EAAAmC,aAAe,IAAIC,EAAAA,QAEhBpC,EAAAqC,iBAAmBvC,EACnBE,EAAAsC,QAAyB,KACzBtC,EAAAuC,gBAAgD,KAChDvC,EAAAwC,kBAA6C,KAC7CxC,EAAAyC,IAAM,IAAIC,EAAAA,YAgClB1C,EAAK2C,WAAa3C,EAAK4C,WAAWhB,GAClC5B,EAAK6C,SAAWC,EAAAA,qBAAqBnB,KA2kBzC,OAvnB8CtB,EAAAA,EAAAA,GA+C5CqB,EAAA9F,UAAAmH,eAAA,WACE,OAAOrH,KAAKmH,UAId3H,OAAAoF,eAAIoB,EAAA9F,UAAA,iBAAc,KAIlB,WACE,OAAOF,KAAK6G,qBALd,SAAmBS,GACjBtH,KAAK6G,gBAAkBS,EACvBtH,KAAKuH,4CAMP/H,OAAAoF,eAAIoB,EAAA9F,UAAA,mBAAgB,KAIpB,WACE,OAAOF,KAAK8G,uBALd,SAAqBU,GACnBxH,KAAK8G,kBAAoBU,EACzBxH,KAAKuH,4CAMP/H,OAAAoF,eAAIoB,EAAA9F,UAAA,SAAM,KAGV,WACE,OAAOF,KAAKyH,iBAJd,SAAW3C,GACT9E,KAAK0H,UAAU5C,oCAOjBkB,EAAA9F,UAAAqH,SAAA,SACED,EACAE,GAEAxH,KAAK2H,cAAcL,EAAgBE,GAAkB1F,MACnD,eACA,SAAA0B,GACE,MAAMA,MAKNwC,EAAA9F,UAAAyH,cAAN,SACEL,EACAE,8GAEuBI,IAAnBN,IACFA,EAAiBO,EAAU7H,KAAK6G,uBAGTe,IAArBJ,IACFA,EAAmBK,EAAU7H,KAAK8G,oBAG/BQ,IACHA,EAAiB,qBAIF,6BAAA,CAAA,EAAMC,EAAAA,SAASvH,KAAK8E,OAAQ0C,kBAArC5F,EAASkG,EAAAxF,OACTyF,EAAmB/H,KAAKgI,0BAA0BpG,GAClDqG,EAAYjI,KAAKkI,YAAYZ,EAAgBS,GAEnD/H,KAAKmI,+BAA+Bb,GACpCtH,KAAKoI,gBAAgBH,GAGjBI,GAAqB,EAGT,IADd7I,OAAOkG,KAAKuC,GAAWK,QAAO,SAAAjD,GAAO,MF3JT,mBE2JSA,KAClC1E,QACHX,KAAKuI,IF7JuB,oBE+J5BvI,KAAKwI,cF/JuB,kBEgK5BH,GAAqB,GAGrBrI,KAAKmE,OACL3E,OAAOkG,KAAKuC,GAAWtH,OAAS,IAC/BX,KAAKuI,IFrKsB,oBEuK5BvI,KAAKyI,WFvKuB,iBEyK1B,IAAI1C,EAAAA,YAAY,GAAI,CAAC9B,KAEvBoE,GAAqB,GAEnBA,GACFrI,KAAK0I,uBAAuB,CAC1BC,UAAU,EACVC,WAAW,iBAIf,wCAIJ5C,EAAA9F,UAAAkI,gBAAA,SAAgBH,GACdjI,KAAKwG,WAAayB,EAClBjI,KAAKuG,qBAAqB9E,KAAKzB,KAAKwG,YACpCxG,KAAKqG,qBAAqB5E,KAAKzB,KAAK6I,cAAc7I,QAG1CgG,EAAA9F,UAAA2I,cAAV,SAAwBC,EAAqBC,GAA7C,IAAAzE,EAAAtE,KACE,YAD2C,IAAA+I,IAAAA,GAAA,GACvCD,EAAQrD,SACVrF,EAAA,GACM2I,EAAS/I,KAAKgJ,OAAS,GACxBxJ,OAAOyJ,QAAQH,EAAQrD,UAAUyD,QAClC,SAACC,EAAUrB,SAAAsB,EAAAjG,EAAA2E,EAAA,GAACzC,EAAA+D,EAAA,GAAKC,EAAAD,EAAA,GACTE,EAAchF,EAAKuE,cAAcQ,GAAiC,GAcxE,OAZEC,GACQ,mBAARjE,GACA7F,OAAOkG,KAAK4D,GAAa3I,OAAS,IAElCwI,EAAG/I,EAAA,GACE+I,IAAGI,EAAA,IACLlE,GAAGjF,EAAA,GACE+I,GAAOA,EAAI9D,GAAO8D,EAAI9D,GAAO,GAC9BiE,GAAWC,KAIbJ,IAET,KAIGL,EAAQE,QAInBhD,EAAA9F,UAAAsJ,sBAAA,WAAA,IAAAlF,EAAAtE,KACER,OAAOkG,KAAK1F,KAAKyF,UAAUgE,SAAQ,SAAAC,GACjC,IAAMZ,EAAUxE,EAAKiE,IAAImB,GAGzB,GAAIZ,aAAmB/C,EAAAA,YACrB+C,EAAQa,cAAc,CAAEhB,UAAU,SAG/B,GAAIG,aAAmB9C,EAC1B8C,EAAQU,6BAGL,GAAIV,aAAmBc,EAAAA,UAC1B,IAAK,IAAIpJ,EAAI,EAAGA,EAAKsI,EAAsBrD,SAAS9E,OAAQH,IAErDsI,EAAsBrD,SAASjF,aAAcuF,EAAAA,YAC9C+C,EAAsBrD,SAASjF,GAAmBmJ,cAAc,CAChEhB,UAAU,IAKXG,EAAsBrD,SAASjF,aAAcwF,GAE5C8C,EAAsBrD,SAASjF,GAE9BgJ,4BAObxD,EAAA9F,UAAA2J,2BAAA,WAAA,IAAAvF,EAAAtE,KACEA,KAAKmI,+BAA+B,IAEpC3I,OAAOkG,KAAK1F,KAAKyF,UAAUgE,SAAQ,SAAAC,GACjC,IAAMZ,EAAUxE,EAAKiE,IAAImB,GAGzB,GAAIZ,aAAmB/C,EAAAA,YACrB+C,EAAQgB,UAAU,KAAM,CAAElB,WAAW,IACrCE,EAAQiB,gBAAgB,CAAEpB,UAAU,IACpCG,EAAQkB,eAAe,CAAErB,UAAU,SAGhC,GAAIG,aAAmB9C,EAC1B8C,EAAQe,kCAGL,GAAIf,aAAmBc,EAAAA,UAC1B,IAAK,IAAIpJ,EAAI,EAAGA,EAAKsI,EAAsBrD,SAAS9E,OAAQH,IAErDsI,EAAsBrD,SAASjF,aAAcuF,EAAAA,aAC9C+C,EAAsBrD,SACtBjF,GACgBsJ,UAAU,KAAM,CAAElB,WAAW,IAC7CE,EAAsBrD,SACtBjF,GACgBuJ,gBAAgB,CAAEpB,UAAU,IAC5CG,EAAsBrD,SAASjF,GAAmBwJ,eAAe,CACjErB,UAAU,KAKXG,EAAsBrD,SAASjF,aAAcwF,GAE5C8C,EAAsBrD,SAASjF,GAE9BqJ,gCAKX7J,KAAKoI,gBAAgB,KAGvBpC,EAAA9F,UAAA+J,aAAA,SAA0BnF,GACxB,OAAOmF,EAAAA,aAAanF,EAAQ,CAAEoF,kBAAkB,KAGlDlE,EAAA9F,UAAAiK,aAAA,SACEC,EACAC,GAEA,OAAOF,EAAAA,aAAaC,EAAKC,EAAO,CAAEH,kBAAkB,KAGhDlE,EAAA9F,UAAAoK,uBAAN,SAA6BhD,6FAC3BtH,KAAK6G,gBAAkBS,mBAEd,6BAAA,CAAA,EAAMtH,KAAK2H,wBAAlB,MAAA,CAAA,EAAOG,EAAAxF,eAEP,wCAIJ0D,EAAA9F,UAAAqK,kBAAA,SAAkBjD,GAChBtH,KAAKsK,uBAAuBhD,GAAgBxF,MAC1C,eACA,SAAA0B,GACE,MAAMA,MAKZwC,EAAA9F,UAAAsK,kBAAA,WACE,OAAOxK,KAAK6G,iBAGdb,EAAA9F,UAAAuK,oBAAA,WACEzK,KAAKuK,kBAAkB,KAEzBvE,EAAA9F,UAAAwK,yBAAA,WACE,OAAO1K,KAAKsK,uBAAuB,KAG/BtE,EAAA9F,UAAAyK,yBAAN,SAA+BnD,6FAC7BxH,KAAK8G,kBAAoBU,mBAEhB,6BAAA,CAAA,EAAMxH,KAAK2H,wBAAlB,MAAA,CAAA,EAAOG,EAAAxF,eAEP,wCAIJ0D,EAAA9F,UAAA0K,oBAAA,SAAoBpD,GAClBxH,KAAK2K,yBAAyBnD,GAAkB1F,MAC9C,eACA,SAAA0B,GACE,MAAMA,MAKZwC,EAAA9F,UAAA2K,oBAAA,WACE,OAAO7K,KAAK8G,mBAIJd,EAAA9F,UAAAgH,WAAV,SAAqBhB,GAArB,IAAA5B,EAAAtE,KACQ8K,EAAwB,GAiC9B,YA/BelD,IAAX1B,GACF1G,OAAOkG,KAAKQ,GAAQuD,SAAQ,SAAApE,GACtBa,EAAOb,aAAgBW,EAEzB8E,EAAUzF,GAAOf,EAAK4C,WACnBhB,EAAOb,GAA+B4B,YAIrCf,EAAOb,aAAgBuE,EAAAA,UAEtB1D,EAAOb,GAAmBI,SAAS,aAAcO,EAGlD8E,EAAUzF,GAAOf,EAAK4C,WAClBhB,EAAOb,GAAmBI,SAAS,GAElCwB,YAIL6D,EAAUzF,GAAQa,EAAOb,GAAmBI,SAAS,GAAGlE,MAI1DuJ,EAAUzF,GAAOa,EAAOb,MAMzByF,GAGT9E,EAAA9F,UAAA8H,0BAAA,SAA0BgB,GAA1B,IAAA1E,EAAAtE,KACQ+K,EAAsC,GA4B5C,OA1BA/B,EAAOS,SAAQ,SAACjG,GACVA,QAA+BoE,IAAtBpE,EAAMwH,aACjBxL,OAAOkG,KAAKlC,EAAMwH,aAAavB,SAAQ,SAACpE,GACjC0F,EAAavH,EAAMyH,YACtBF,EAAavH,EAAMyH,UAAY,KAMxB,IAFNF,EAAavH,EAAMyH,UAAuBC,QACzC1H,EAAMwH,YAAY3F,KAGnB0F,EAAavH,EAAMyH,UAAuB/H,KACzCM,EAAMwH,YAAY3F,YAMHuC,IAAnBpE,EAAM2H,UAA0B3H,EAAM2H,SAASxK,SACjDoK,EAAavH,EAAMyH,UAAY3G,EAAK0D,0BAClCxE,EAAM2H,cAKLJ,GAGC/E,EAAA9F,UAAAgI,YAAV,SACEZ,EACAS,GAEA,IAAMqD,EAAuBvD,EAAUP,GACvC,OAAO+D,EACLD,EACArD,GACA,SAACuD,EAAUC,GACT,GAMI5L,MAAM6L,QAAQF,IACd3L,MAAM6L,QAAQD,IAEA,IADdD,EAAShD,QAAO,SAAAmD,GAAW,OAA+B,IAA/BF,EAASL,QAAQO,MACzC9K,OARL,OAAO2K,EAASI,OAAOH,OAerBvF,EAAA9F,UAAAiI,+BAAV,SACEa,EACAvD,GAEKA,IACHA,EAAWzF,KAAKyF,UAElBjG,OAAOkG,KAAKD,GAAUgE,SAAQ,SAAAC,GAC5B,IAAMZ,EAAUrD,EAAUiE,GAG1B,GAAIZ,aAAmB/C,EAAAA,YACjBiD,GAAUA,EAAOU,GACnBZ,EAAQgB,UAAU,CAAE6B,eAAe,IAE/B7C,EAAQE,SAA2C,IAAjCF,EAAQE,OAAO2C,eACnC7C,EAAQgB,UAAU,WAKnB,GAAIhB,aAAmB9C,EAC1B8C,EAAQX,+BACNa,GAAUA,EAAOU,GACZV,EAAOU,GACR,SAIH,GAAIZ,aAAmBc,EAAAA,UAC1B,IAAK,IAAIpJ,EAAI,EAAGA,EAAKsI,EAAsBnI,OAAQH,IAE7CsI,EAAQtI,aAAcuF,EAAAA,YACpBiD,GAAUA,EAAOxI,IAAMwI,EAAOxI,GAAGkJ,GACnCZ,EAAQtI,GAAGsJ,UAAU,CAAE6B,eAAe,IAEtC7C,EAAQtI,GAAGwI,SACyB,IAApCF,EAAQtI,GAAGwI,OAAO2C,eAElB7C,EAAQtI,GAAGsJ,UAAU,MAIhBhB,EAAQtI,aAAcwF,GAC7B8C,EAAQtI,GAAG2H,+BACTa,GAAUA,EAAOxI,IAAMwI,EAAOxI,GAAGkJ,GAC5BV,EAAOxI,GAAGkJ,GACX,QAYN1D,EAAA9F,UAAAuH,UAAV,WAAA,IAAAnD,EAAAtE,KAEQ8E,EAAS9E,KAAK4G,QAChB5G,KAAKiK,aAAajK,KAAK4G,SACvB5G,KAAKiG,aACL,IAAIjG,KAAKiG,kBACT2B,EA+CJ,YA7CeA,IAAX9C,GAEFtF,OAAOkG,KAAK1F,KAAKyF,UACd6C,QAAO,SAAA1C,GAAQ,MF9gBY,mBE8gBZA,KACf6D,SAAQ,SAAApE,GAEP,GAAIf,EAAKmB,SAASJ,aAAgBW,EAChClB,EAAOO,GAAQf,EAAKmB,SAASJ,GAA+BP,YAIzD,GAAIR,EAAKmB,SAASJ,aAAgBuE,EAAAA,UAAW,CAEhD9E,EAAOO,GAAO,GAEd,IACE,IAAI7E,EAAI,EACRA,EAAK8D,EAAKmB,SAASJ,GAAmBI,SAAS9E,OAC/CH,IACA,CACA,IAAIe,OAAK,GAOPA,EAJC+C,EAAKmB,SAASJ,GAAmBI,SAASjF,aAC3CwF,EAGU1B,EAAKmB,SAASJ,GAAmBI,SACzCjF,GAC0BsE,OAEnBR,EAAKmB,SAASJ,GAAmBI,SAASjF,GAAGe,QAE3C/B,OAAOkG,KAAKnE,GAAOZ,OAAS,GACvCmE,EAAOO,GAAKnC,KAAK3B,SAOrBuD,EAAOO,GAAOf,EAAKmB,SAASJ,GAAK9D,SAIjCvB,KAAKiG,aACTjG,KAAKmK,aAAanK,KAAKiG,aAAcnB,GACrCA,GASIkB,EAAA9F,UAAAwH,UAAV,SAAoB5C,GAApB,IAAAR,EAAAtE,KACM8E,aAAkB9E,KAAKiG,aACzBjG,KAAK4G,QAAU5G,KAAKiK,aAAanF,GAEjC9E,KAAK4G,QAAU5G,KAAKmK,aAAanK,KAAKiG,aAAcnB,GAItDtF,OAAOkG,KAAK1F,KAAKyF,UAAUgE,SAAQ,SAAApE,GAEjC,GAAIf,EAAKmB,SAASJ,aAAgBW,EAC/B1B,EAAKmB,SAASJ,GAA+BP,OAASR,EAAKsC,QACxDtC,EAAKsC,QAAQvB,GACb,QAID,GAAIf,EAAKmB,SAASJ,aAAgBuE,EAAAA,UAAW,CAQhD,IAPA,IAAMgC,EAActH,EAAKsC,QAAUtC,EAAKsC,QAAQvB,GAAO,GACjDwG,EAAYvH,EAAKmB,SAASJ,GAC1ByG,EAAcD,EAAUpG,SAAS,aAAcO,EAC/C+F,EAAiBF,EAAUpG,SAAS,GACpCuG,EAAcH,EAAUpG,SAAS,GAGX,IAArBoG,EAAUlL,QACfkL,EAAUI,SAAS,GAGrB,mBAASzL,GACP,GAAIsL,EAAa,CAEf,IAAMI,EAAmB,IAAIlG,EAC3B+F,EAAe9F,aACf8F,EAAe9E,YAGjBiF,EAAiBC,UAAU7H,GAE3B,IAAM8H,EAAkBC,EACtBN,EAAe9F,aACf8F,EAAe9E,gBACfW,EACAtD,EAAKqC,kBAED2F,EAAYhI,EAAKyC,IAAIwF,MAAMH,GAGjC5M,OAAOkG,KAAK4G,EAAU7G,UAAUgE,SAAQ,SAAA+C,GACtCN,EAAiBzD,WAAW+D,EAASF,EAAU7G,SAAS+G,OAI1DN,EAAiBO,aAAaC,WAAU,SAAAlI,GACtC0H,EAAiB3E,cAASK,EAAWtD,EAAKwC,sBAG5C+E,EAAUpG,SAASvC,KAAKgJ,GAGvBL,EAAUpG,SAASjF,GAA6BsE,OAC/CR,EAAKsC,SAAWgF,GAAeA,EAAYpL,GACvCoL,EAAYpL,GACZ,OACD,CAEL,IAAMmM,EACJrI,EAAKsC,SAAWgF,GAAeA,EAAYpL,GACvCoL,EAAYpL,QACZoH,EACAgF,EAAiB,IAAI7G,EAAAA,YACzB4G,EACAX,EAAYa,WAEdD,EAAeT,UAAU7H,GAGzBuH,EAAUpG,SAASvC,KAAK0J,KAhDnBpM,EAAI,EAAGA,EAAIoL,EAAYjL,OAAQH,MAA/BA,OAsDN,CACH,IAAMsM,EAAYxI,EAAKsC,QAAUtC,EAAKsC,QAAQvB,GAAO,GACrDf,EAAKmB,SAASJ,GAAK0H,SACjBzI,EAAKsC,SAAWkG,EAAYA,OAAYlF,OAI9C5H,KAAKyG,aAAahF,KAAKzB,KAAK4G,UAEhCZ,GAvnB8CgH,EAAAA,oBAynB9BX,EACdpG,EACAC,EACAsB,EACAb,QAAA,IAAAA,IAAAA,EAAAvC,GAGA,IAAM6I,EAA+CC,EAAAA,iBACnDC,EAAAA,iBACAC,6BAA6BnH,EAAc,IAGvCoH,EAAiDH,EAAAA,iBACrDC,EAAAA,iBACAC,6BACAnH,EACA,GACAuB,GAAoBA,EAAiB8F,OACjC9F,EAAiB8F,YACjB1F,GAGA2F,EAAkB,GAClBV,EAAY,IAAIW,EAAAA,UAgJtB,OA7IAhO,OAAOkG,KAAKQ,GACToC,QAAO,SAAAjD,GAAO,OAAsB,IAAtBA,EAAI6F,QAAQ,SAC1BzB,SAAQ,SAAAgE,GAEP,IAAMC,EAA+C,GACrDL,EAAyB5D,SAAQ,SAAAkE,GAE7BC,EACED,EACAF,EACAI,EAAeC,YAAYC,OAG7BL,EAAuBxK,KAAKyK,MAKhC,IAAMK,EAA6C,GACnDf,EAAuBxD,SAAQ,SAAAkE,GAE3BC,EACED,EACAF,EACAI,EAAeI,OAAOF,OAGxBC,EAAqB9K,KAAKyK,MAK9B,IAAMO,EAA+C,GACrDb,EAAyB5D,SAAQ,SAAAkE,GAE7BC,EACED,EACAF,EACAI,EAAeI,OAAOF,OAGxBG,EAAuBhL,KAAKyK,MAIhC,IAAMtJ,EAAyC,CAC7CG,KAAM+I,EAAgBE,GACtBhJ,oBAAqB,GACrBC,sBAAuB,SAGIkD,IAAzBvD,EAAgBG,OAClBH,EAAgBG,KAAO0B,EAAOuH,IAI9B9N,MAAM6L,QAAQnH,EAAgBG,OAC9BH,EAAgBG,KAAK7D,OAAS,GAC9B0D,EAAgBG,KAAK8D,QACnB,SAAC6F,EAAoBC,GACnB,OAAAA,EAAQ,GAAmC,mBAAvBD,KACtBxN,OAAS,IAEX0D,EAAgBG,KACb8D,QACC,SAAC6F,EAAoBC,GACnB,OAAAA,EAAQ,GAAmC,mBAAvBD,KAEvB1E,SAAQ,SAAA0E,GACP,OAAA9J,EAAgBI,oBAAoBvB,KAAKiL,MAE7C9J,EAAgBG,KAAOH,EAAgBG,KAAK,IAG9C6I,EAAyB5D,SAAQ,SAAAkE,GAC/B,GACEA,EAAmBU,eAAiBZ,GACpCE,EAAmBI,OAASF,EAAeC,YAAYC,KAQvD,IAAK,IAAMO,KAJPX,EAAmBI,OAASF,EAAeI,OAAOF,MACpD1J,EAAgBK,sBAAsBxB,KAAKyK,GAGvBY,EAAAA,gBACpB,GAAIA,EAAAA,gBAAgB1O,eAAeyO,GAAU,CAE3C,GACEE,EACER,EACAE,EACAT,IAGEgB,EAAiBd,EAAoBW,GAAU,CACjD,IAIMI,EAAiBC,EAHrBzI,EAAOuH,aAAsBzH,EACzBE,EAAOuH,GAAW3I,YAClB8C,EAGJ+F,GAEFiB,EAAanB,EAAWpJ,EAAiBqK,GAK7C,GAAIG,EAAiBlB,EAAoBW,GAAU,CACjD,IAAMQ,EAAmBC,EACvBtB,EACAE,GAEFiB,EAAanB,EAAWpJ,EAAiByK,GAI3C,GAAIE,EAAkBrB,EAAoBW,GAAU,CAClD,IAAMW,EAAkBC,EACtBvB,EACAD,EACAD,GAEFmB,EAAanB,EAAWpJ,EAAiB4K,QAQjD5K,EAAgBG,gBAAgBwB,GAChC3B,EAAgBG,gBAAgBoF,EAAAA,UAEhC2D,EAAgBE,GAAapJ,EAAgBG,KAE7C+I,EAAgBE,GAAa,IAAI9G,EAAiBtC,MAIjDkJ,EAMP,SAASoB,EACPQ,EACAxB,GAEA,OAAO,SAAS7E,GAOd,OAAOsG,EADQ,IAJbC,EACEvG,OACqBlB,IAArBuH,EAAiCA,EAAmBrG,EAAQvH,MAC5DiG,GACA7G,OAC6BgN,EAAoB,mBAIzD,SAASuB,EACPvB,EACAD,EACAD,GAEA,OAAO,SAAS3E,GACd,IAAKA,EACH,OAAO,KAGT,IAAIwG,GACFxG,EAAQjE,SAAUiE,EAAQjE,OAAOtD,OAC7BsL,EAAU0C,wBAAwBzG,EAAQvH,MAAOoM,IAGlD2B,GAAW5B,EAAuB/M,OAAS,IAM9C2O,EAGe,IARQE,EACrB1G,EACA2E,EACAjG,GAGec,QACb,SAAC9E,GAA2B,OAAAA,EAAMyH,WAAawC,KAC/C9M,QAGN,OAAOyO,EAAiBE,EAAS3B,EAAoB,oBAIzD,SAASoB,EACPtB,EACAE,GAEA,OAAO,SAAS7E,GAOd,OAAOsG,EAD4D,IAsFvE,SACEK,EACAhC,GAEA,OAAOgC,EAAenH,QACpB,SAAC9E,GAEC,OAACA,EAAM2H,SAASxK,QACd6C,EAAM2H,SAAS7C,QAAO,SAAA6C,GAAY,OAAAA,EAASF,WAAawC,MAC1DjK,EAAMyH,WAAawC,KA/FLiC,CAL0BF,EACxC1G,EACA2E,EACAjG,GAE2CiG,GAAW9M,OACvBgN,EAAoB,qBAIzD,SAASa,EACPR,EACA2B,EACAtK,GAEA,OACE2I,EAAqBrN,SAAWgP,EAAkBhP,SAChDuF,EAAOb,aAAgBW,GACvBE,EAAOb,aAAgBuE,EAAAA,YACvBoE,EAAqBrN,OAAS,GAAkC,IAA7BgP,EAAkBhP,OAI3D,SAASqO,EACPrB,EACAW,GAEA,OACEX,EAAmBI,OAASQ,EAAAA,gBAAgBD,SACL1G,IAAvCiF,EAAUc,EAAmBI,MAQjC,SAASc,EACPlB,EACAW,GAEA,OACEsB,EAAwBjC,EAAoBW,IAC5CX,EAAmBI,OAASF,EAAegC,OAAO9B,MAClDO,IAAYT,EAAegC,OAAOvB,QAQtC,SAASG,EACPd,EACAW,GAEA,OACEsB,EAAwBjC,EAAoBW,IAC5CX,EAAmBI,OAASF,EAAeI,OAAOF,MAClDO,IAAYT,EAAeI,OAAOK,QAItC,SAASsB,EACPjC,EACAW,GAEA,OACEX,EAAmBI,OAASQ,EAAAA,gBAAgBD,SACL1G,IAAvCiF,EAAUc,EAAmBI,MAIjC,SAASa,EACPnB,EACApJ,EACA8J,QAQ6BvG,IAAzBvD,EAAgBG,OAClBH,EAAgBG,KAAO0B,EAAOuH,IAGhCpJ,EAAgBI,oBAAoBvB,KAAKiL,IAqB7C,SAASP,EACPD,EACAF,EACAqC,GAEA,OACEnC,EAAmBU,eAAiBZ,GACpCE,EAAmBI,OAAS+B,EAIhC,SAASN,EACP1G,EACAzD,EACAmC,GAEA,IAAM1C,EACJgE,EAAQjE,kBAAkBmB,EACrB8C,EAAQjE,OAAiCC,OAC1CgE,EAAQjE,OACRiE,EAAQjE,OAAOtD,MACf,GAMN,OAJIuD,IACFA,EAAOO,GAAOyD,EAAQvH,OAGjB8N,EAAkBvG,EAAShE,EAAQ0C,GAG5C,SAAS6H,EACPvG,EACAiH,EACAvI,GAMA,OAHEsB,EAAQjE,QAAUiE,EAAQjE,OAAOtD,MAC7ByO,EAAAA,aAAaD,EAAgBvI,GAC7B,GAIR,SAAS4H,EACPE,EACA3B,EACAsC,SAEA,OAAOX,EACH,aAEGW,GAAY,CACX9L,OAAO,EACP4J,KAAMJ,EAAmBI,SAUnC,IAAMF,EAAiB,CACrBI,OAAQ,CACNF,KAAM,mBACNO,QAAS,qBAEXR,YAAa,CACXC,KAAM,yBAER8B,OAAQ,CACN9B,KAAM,mBACNO,QAAS,oCC/iCb,SAAA4B,IAAA,IAAA5L,EAAA,OAAAC,GAAAA,EAAA1D,MAAAb,KAAAU,YAAAV,YAEYsE,EAAA6L,eAAiBnK,EACjB1B,EAAAqC,iBAAmBvC,IAsO/B,OAzOwCO,EAAAA,EAAAA,GAItCuL,EAAAhQ,UAAAqM,MAAA,SACEtG,EACAmK,EAIA1M,GANF,IAAAY,EAAAtE,KASE,GACEoQ,IACCvM,EAAyBuM,IACxBxM,EAAewM,IACf3M,EAAyB2M,MAC1B1M,EAED,OAAO1D,KAAKuM,MAAMtG,OAAc2B,EAAWwI,GAI7C,IAAKA,EAAgB,CACnB,IACMlK,GADS,IAAID,GACEoK,gBACrBD,EAAchQ,EAAA,GACP8F,EACFoK,KAAI,SAAC5G,SAAe,OAAA5B,EAAA,IAClB4B,EAAM+D,WAAY,QAEpBvE,QACC,SAACqH,EAAUC,GAAiB,OAAApQ,EAAA,GAAMmQ,EAAQC,KAC1C,KAKR,IAIIxM,EAuBAyM,EA3BEC,EAAgChN,EAElCI,EAAmC,KACnCC,EAAyC,KAGhC,MAAT2M,IACE7M,EAAyB6M,KAE3B5M,EAAiC,MAApB4M,EAAM5M,WAAqB4M,EAAM5M,WAAa,KAC3DC,EAA2C,MAAzB2M,EAAM3M,gBAA0B2M,EAAM3M,gBAAkB,KAC1EC,EAA6B,MAAlB0M,EAAM1M,SAAmB0M,EAAM1M,cAAW4D,GAEnDhE,EAAe8M,KAEjB5M,EAAaA,GAAc,GACvB4M,EAAM7D,WAAW/I,EAAWZ,KAAKwN,EAAM7D,WAE3C9I,EAAkBA,GAAmB,GACjC2M,EAAMtK,gBAAgBtC,EAAWZ,KAAKwN,EAAMtK,iBAG7C3C,EAAyBiN,KAC5BA,EAAMC,uBAAyB,CAAEC,gBAAiB,CAAEC,QAAQ,WAMzCjJ,IAAnBwI,IACFK,EAAoBL,QAICxI,IAAnBwI,IACFK,EAAiBrQ,EAAA,GAAQJ,KAAK8Q,kBAAkB7K,IAEhDzG,OAAOkG,KAAK+K,GAAmBhH,SAAQ,SAAApE,GA0CrC,IACQ0L,GAAAA,EAAYN,EAAkBpL,MAIjC1F,MAAM6L,QAAQuF,IACfA,EAAU9Q,aACW,iBAAd8Q,SACenJ,IAArBmJ,EAAUpQ,aACaiH,IAArBmJ,EAAUpQ,QACTnB,OAAOkG,KAAKqL,GAAWpQ,SAAWoQ,EAAUpQ,QAjDlD8P,EAAkBpL,GAAOf,EAAKiI,MAC5BkE,EAAkBpL,GAAKpF,iBACvB2H,EACAoJ,EAAAA,GACMN,EAAMC,uBACN,CAAEA,uBAAwBD,EAAMC,wBAChC,GAAE,CACN5M,gBAAeA,EACfC,SAAQA,EACRF,WAAUA,KA4ChB,WACE,IAA8C,IAA1CnE,MAAM6L,QAAQiF,EAAkBpL,IAClC,OAAO,EAGT,IAAM0L,EAAYN,EAAkBpL,GAAK,GAEzC,OACE0L,EAAU9Q,aACW,iBAAd8Q,SACenJ,IAArBmJ,EAAUpQ,aACaiH,IAArBmJ,EAAUpQ,QACTnB,OAAOkG,KAAKqL,GAAWpQ,SAAWoQ,EAAUpQ,QApD9CsQ,KACER,EAAkBpL,GAAK,GAAGpF,YAE5BwQ,EAAkBpL,GAAOd,EAAArE,UAAMgR,MAAKtQ,KAAA0D,EAClCmM,EAAkBpL,GAAKiL,KAAI,SAACa,GAC1B,OAAA7M,EAAKiI,MAAM4E,EAAsBlR,iBAAa2H,EAAWoJ,EAAAA,GACnDN,EAAMC,uBACN,CAAEA,uBAAwBD,EAAMC,wBAChC,GAAE,CACN5M,gBAAeA,EACfC,SAAQA,EACRF,WAAUA,SAMhB2M,EAAkBpL,GAAOd,EAAArE,UAAMgR,MAAKtQ,KAAA0D,EAClCmM,EAAkBpL,GAAKiL,KAAI,SAACa,GAC1B,OAAA7M,EAAKwE,QAAQqI,YAwC3BrN,EAAaA,GAAcA,EAAWwE,QAAO,SAAAuE,GAAa,OAAAA,KAC1D9I,EACEA,GAAmBA,EAAgBuE,QAAO,SAAAuE,GAAa,OAAAA,KAGzD,IAAMT,EAAkBC,EACtBpG,EACAwK,EACAC,GAASA,EAAMC,uBACf3Q,KAAK2G,kBAEDyK,EAAY7M,EAAArE,UAAMqM,MAAK3L,KAAAZ,KAACoM,EAAehM,EAAA,GACvC2D,GAAmB,GACnBC,GAAY,GACZF,GAAc,KAKduN,EAAmB,IAAIrL,EAC3BC,EACAwK,EACA,CACE1M,gBAAeA,EACfC,SAAQA,EACRF,WAAUA,IAYd,OAPAtE,OAAOkG,KAAK0L,EAAU3L,UAAUgE,SAAQ,SAAApE,GACtCgM,EAAiB5I,WAAWpD,EAAK+L,EAAU3L,SAASJ,OAItDgM,EAAiB5E,aAAaC,WAAU,WAAM,OAAA2E,EAAiB9J,cAASK,EAAW8I,GAASA,EAAMC,2BAE3FU,GASDnB,EAAAhQ,UAAA4Q,kBAAR,SACE7K,EACAzB,GAFF,IAAAF,EAAAtE,UAEE,IAAAwE,IAAAA,EAAA,IAEA,IAAI8M,GAAW,EAETxM,EAAcmB,EAAekE,EAAAA,aAAalE,EAAczB,GAAQA,EAwBtE,OAvBehF,OAAOkG,KAAKZ,GAEpB2E,SAAQ,SAACgE,GACV3I,EAAO2I,SAA2C7F,IAA7B9C,EAAO2I,GAAW9M,QAEV,IAA7BmE,EAAO2I,GAAW9M,QAClBnB,OAAOkG,KAAKZ,EAAO2I,GAAW,IAAI9M,OAAS,GAC3CmE,EAAO2I,GAAW,GAAGxN,cAErB6E,EAAO2I,GAAa,CAClBnJ,EAAKwM,kBAAkBhM,EAAO2I,GAAW,GAAGxN,eAIf,IAA7B6E,EAAO2I,GAAW9M,SACpB6D,EAAKiJ,GAAa,CAAC,IACnB6D,GAAW,IAGb9M,EAAKiJ,QAAa7F,KAIlB0J,EACKtR,KAAK8Q,kBAAkB7K,EAAczB,GAGvCM,GAEXoL,GAzOwClJ,EAAAA,uGHPJ","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { AbstractControlOptions, AsyncValidatorFn, ValidatorFn } from '@angular/forms';\nimport { ValidatorOptions } from 'class-validator';\nimport { isNullOrUndefined } from 'util';\n\nexport interface DynamicFormGroupConfig {\n  validator?: ValidatorFn | undefined;\n  asyncValidator?: AsyncValidatorFn | undefined;\n  validators?: ValidatorFn[] | undefined;\n  asyncValidators?: AsyncValidatorFn[] | undefined;\n  updateOn?: any | undefined;\n  customValidatorOptions?: ValidatorOptions | undefined;\n}\nexport function isDynamicFormGroupConfig(options:DynamicFormGroupConfig) {\n  return options && !isNullOrUndefined(options['customValidatorOptions']);\n}\nexport function isLegacyOrOpts(options: DynamicFormGroupConfig) {\n  return options && (!isNullOrUndefined(options['validator']) || !isNullOrUndefined(options['asyncValidator']));\n}\nexport function isAbstractControlOptions(options: AbstractControlOptions | DynamicFormGroupConfig) {\n  return (\n    options &&\n    (!isNullOrUndefined(options.validators) ||\n      !isNullOrUndefined(options.asyncValidators) ||\n      !isNullOrUndefined(options.updateOn))\n  );\n}\n","import { FormControl } from '@angular/forms';\r\n\r\nexport function foreverInvalid(c: FormControl) {\r\n  return {\r\n    foreverInvalid: {\r\n      valid: false\r\n    }\r\n  };\r\n}\r\nexport const FOREVER_INVALID_NAME = 'foreverInvalid';\r\n","import { FormControl } from '@angular/forms';\nimport { ValidationMetadata } from 'class-validator/metadata/ValidationMetadata';\nimport { MetadataKeys, RadioOption, TextareaOption } from '@libertyware/ngx-form-core';\n\nimport { DynamicFormGroupField } from '../models/dynamic-form-group-field';\nimport { DynamicFormGroup } from './dynamic-form-group';\n\nexport class DynamicFormControl extends FormControl {\n  public validationDefinitions: ValidationMetadata[];\n\n  constructor(fieldDefinition: DynamicFormGroupField) {\n    super(fieldDefinition.data, fieldDefinition.validationFunctions);\n\n    this.validationDefinitions = fieldDefinition.validationDefinitions;\n  }\n\n  private get formModel(): any {\n    return (this.parent as DynamicFormGroup<any>).object;\n  }\n\n\n  get hint(): string {\n    return this.metaData(MetadataKeys.HINT);\n  }\n\n  get readableName(): string {\n    return this.metaData(MetadataKeys.DISPLAY_NAME) || this.ControlName;\n  }\n\n  get placeholder(): string {\n    return this.metaData(MetadataKeys.PLACEHOLDER);\n  }\n\n  private metaData(key: string): any {\n    return Reflect.getMetadata(key, this.formModel, this.ControlName);\n  }\n\n  get ControlName(): string {\n    const controls: any = this.parent.controls;\n    return Object.keys(controls).find(name => this === controls[name]) as string;\n  }\n\n  get radioOptions(): RadioOption[] {\n    return this.metaData(MetadataKeys.RADIO_OPTIONS) || [];\n  }\n\n  get textareaOptions(): TextareaOption {\n    return this.metaData(MetadataKeys.TEXTAREA_OPTIONS);\n  }\n}\n","import {\n  AbstractControl,\n  AbstractControlOptions,\n  AsyncValidatorFn,\n  FormArray,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  ValidatorFn\n} from '@angular/forms';\nimport { classToClass, plainToClass } from 'class-transformer';\nimport { ClassType } from 'class-transformer/ClassTransformer';\nimport {\n  getFromContainer,\n  MetadataStorage,\n  validate,\n  validateSync,\n  ValidationError,\n  ValidationTypes,\n  Validator,\n  ValidatorOptions\n} from 'class-validator';\nimport { ValidationMetadata } from 'class-validator/metadata/ValidationMetadata';\nimport 'reflect-metadata';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport {\n  Dictionary,\n} from '../models/dictionary';\nimport {\n  ShortValidationErrors,\n} from '../models/short-validation-errors';\nimport {\n  DynamicFormGroupField,\n} from '../models/dynamic-form-group-field';\nimport {\n  foreverInvalid,\n  FOREVER_INVALID_NAME\n} from '../validators/forever-invalid.validator';\nimport { DynamicFormControl } from './dynamic-form-control';\nimport { WidgetOptions, getFormFieldsOptions } from '@libertyware/ngx-form-core';\n\nimport cloneDeep from 'lodash.clonedeep';\nimport mergeWith from 'lodash.mergewith';\n\n// Enforces the properties of the object, if supplied, to be of the original type or DynamicFormGroup or, FormArray\nexport type FormModel<T> = {\n  [P in keyof T]?: T[P] | DynamicFormGroup<any> | FormArray;\n};\n\nexport class DynamicFormGroup<TModel> extends FormGroup {\n  public nativeValidateErrors = new BehaviorSubject<Dictionary>({});\n  public customValidateErrors = new BehaviorSubject<ShortValidationErrors>({});\n  public formErrors: ShortValidationErrors | null = null;\n  public formFields: Dictionary;\n  public objectChange = new Subject();\n\n  protected FormControlClass = DynamicFormControl;\n  protected _object: TModel | null = null;\n  protected _externalErrors: ShortValidationErrors | null = null;\n  protected _validatorOptions: ValidatorOptions | null = null;\n  protected _fb = new FormBuilder();\n  private _formGen: WidgetOptions[];\n\n  constructor(\n    public factoryModel: ClassType<TModel>,\n    public fields: FormModel<TModel>,\n    validatorOrOpts?:\n      | ValidatorFn\n      | ValidatorFn[]\n      | AbstractControlOptions\n      | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ) {\n    super({}, validatorOrOpts, asyncValidator);\n    /*\n    const classValidators = DynamicFormGroup.getClassValidators<TModel>(\n      this.factoryModel,\n      this.fields,\n      this.defaultValidatorOptions\n    );\n    const formGroup = this._fb.group(\n      classValidators\n    );\n    Object.keys(formGroup.controls).forEach(key => {\n      this.addControl(key, formGroup.controls[key]);\n    });\n    this.valueChanges.subscribe(data => {\n      this.validate(\n        undefined,\n        this.defaultValidatorOptions\n      );\n    });*/\n    this.formFields = this.onlyFields(fields);\n    this._formGen = getFormFieldsOptions(factoryModel);\n  }\n\n  getFormGenData() {\n    return this._formGen;\n  }\n\n  // Getters & Setters\n  set externalErrors(externalErrors: ShortValidationErrors | null) {\n    this._externalErrors = externalErrors;\n    this.validate();\n  }\n  get externalErrors(): ShortValidationErrors | null {\n    return this._externalErrors;\n  }\n\n  set validatorOptions(validatorOptions: ValidatorOptions | null) {\n    this._validatorOptions = validatorOptions;\n    this.validate();\n  }\n  get validatorOptions(): ValidatorOptions | null {\n    return this._validatorOptions;\n  }\n\n  set object(object: TModel) {\n    this.setObject(object);\n  }\n  get object() {\n    return this.getObject();\n  }\n\n  // Public API\n  validate(\n    externalErrors?: ShortValidationErrors,\n    validatorOptions?: ValidatorOptions\n  ) {\n    this.validateAsync(externalErrors, validatorOptions).then(\n      () => {},\n      error => {\n        throw error;\n      }\n    );\n  }\n\n  async validateAsync(\n    externalErrors?: ShortValidationErrors,\n    validatorOptions?: ValidatorOptions\n  ) {\n    if (externalErrors === undefined) {\n      externalErrors = cloneDeep(this._externalErrors);\n    }\n\n    if (validatorOptions === undefined) {\n      validatorOptions = cloneDeep(this._validatorOptions);\n    }\n\n    if (!externalErrors) {\n      externalErrors = {};\n    }\n\n    try {\n      const result = await validate(this.object, validatorOptions);\n      const validationErrors = this.transformValidationErrors(result);\n      const allErrors = this.mergeErrors(externalErrors, validationErrors);\n\n      this.markAsInvalidForExternalErrors(externalErrors);\n      this.setCustomErrors(allErrors);\n\n      // todo: refactor, invalidate form if exists any allErrors\n      let usedForeverInvalid = false;\n      if (\n        Object.keys(allErrors).filter(key => key !== FOREVER_INVALID_NAME)\n          .length === 0 &&\n        this.get(FOREVER_INVALID_NAME)\n      ) {\n        this.removeControl(FOREVER_INVALID_NAME);\n        usedForeverInvalid = true;\n      }\n      if (\n        this.valid &&\n        Object.keys(allErrors).length > 0 &&\n        !this.get(FOREVER_INVALID_NAME)\n      ) {\n        this.addControl(\n          FOREVER_INVALID_NAME,\n          new FormControl('', [foreverInvalid as any])\n        );\n        usedForeverInvalid = true;\n      }\n      if (usedForeverInvalid) {\n        this.updateValueAndValidity({\n          onlySelf: true,\n          emitEvent: false\n        });\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  setCustomErrors(allErrors: any) {\n    this.formErrors = allErrors;\n    this.customValidateErrors.next(this.formErrors as ShortValidationErrors );\n    this.nativeValidateErrors.next(this.collectErrors(this));\n  }\n\n  protected collectErrors(control: Dictionary, isRoot = true): any | null {\n    if (control.controls) {\n      return {\n        ...(isRoot ? this.errors : {}),\n        ...Object.entries(control.controls).reduce(\n          (acc: any, [key, childControl]) => {\n            const childErrors = this.collectErrors(childControl as Dictionary<any>, false);\n            if (\n              childErrors &&\n              key !== 'foreverInvalid' &&\n              Object.keys(childErrors).length > 0\n            ) {\n              acc = {\n                ...acc,\n                [key]: {\n                  ...(acc && acc[key] ? acc[key] : {}),\n                  ...childErrors\n                }\n              };\n            }\n            return acc;\n          },\n          {}\n        )\n      };\n    } else {\n      return control.errors;\n    }\n  }\n\n  validateAllFormFields() {\n    Object.keys(this.controls).forEach(field => {\n      const control = this.get(field);\n\n      // Control\n      if (control instanceof FormControl) {\n        control.markAsTouched({ onlySelf: true });\n      }\n      // Group: recursive\n      else if (control instanceof DynamicFormGroup) {\n        control.validateAllFormFields();\n      }\n      // Array\n      else if (control instanceof FormArray) {\n        for (let i = 0; i < (control as FormArray).controls.length; i++) {\n          // Control in Array\n          if ((control as FormArray).controls[i] instanceof FormControl) {\n            ((control as FormArray).controls[i] as FormControl).markAsTouched({\n              onlySelf: true\n            });\n          }\n          // Group in Array: recursive\n          else if (\n            (control as FormArray).controls[i] instanceof DynamicFormGroup\n          ) {\n            ((control as FormArray).controls[i] as DynamicFormGroup<\n              any\n            >).validateAllFormFields();\n          }\n        }\n      }\n    });\n  }\n\n  resetValidateAllFormFields() {\n    this.markAsInvalidForExternalErrors({});\n\n    Object.keys(this.controls).forEach(field => {\n      const control = this.get(field);\n\n      // Control\n      if (control instanceof FormControl) {\n        control.setErrors(null, { emitEvent: false });\n        control.markAsUntouched({ onlySelf: true });\n        control.markAsPristine({ onlySelf: true });\n      }\n      // Group: recursive\n      else if (control instanceof DynamicFormGroup) {\n        control.resetValidateAllFormFields();\n      }\n      // Array\n      else if (control instanceof FormArray) {\n        for (let i = 0; i < (control as FormArray).controls.length; i++) {\n          // Control in Array\n          if ((control as FormArray).controls[i] instanceof FormControl) {\n            ((control as FormArray).controls[\n              i\n            ] as FormControl).setErrors(null, { emitEvent: false });\n            ((control as FormArray).controls[\n              i\n            ] as FormControl).markAsUntouched({ onlySelf: true });\n            ((control as FormArray).controls[i] as FormControl).markAsPristine({\n              onlySelf: true\n            });\n          }\n          // Group in Array: recursive\n          else if (\n            (control as FormArray).controls[i] instanceof DynamicFormGroup\n          ) {\n            ((control as FormArray).controls[i] as DynamicFormGroup<\n              any\n            >).resetValidateAllFormFields();\n          }\n        }\n      }\n    });\n    this.setCustomErrors({});\n  }\n\n  classToClass<TClassModel>(object: TClassModel) {\n    return classToClass(object, { ignoreDecorators: true });\n  }\n\n  plainToClass<TClassModel, Object>(\n    cls: ClassType<TClassModel>,\n    plain: Object\n  ) {\n    return plainToClass(cls, plain, { ignoreDecorators: true });\n  }\n\n  async setExternalErrorsAsync(externalErrors: ShortValidationErrors) {\n    this._externalErrors = externalErrors;\n    try {\n      return await this.validateAsync();\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  setExternalErrors(externalErrors: ShortValidationErrors) {\n    this.setExternalErrorsAsync(externalErrors).then(\n      () => {},\n      error => {\n        throw error;\n      }\n    );\n  }\n\n  getExternalErrors(): ShortValidationErrors {\n    return this._externalErrors as ShortValidationErrors;\n  }\n\n  clearExternalErrors() {\n    this.setExternalErrors({});\n  }\n  clearExternalErrorsAsync() {\n    return this.setExternalErrorsAsync({});\n  }\n\n  async setValidatorOptionsAsync(validatorOptions: ValidatorOptions) {\n    this._validatorOptions = validatorOptions;\n    try {\n      return await this.validateAsync();\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  setValidatorOptions(validatorOptions: ValidatorOptions) {\n    this.setValidatorOptionsAsync(validatorOptions).then(\n      () => {},\n      error => {\n        throw error;\n      }\n    );\n  }\n\n  getValidatorOptions(): ValidatorOptions {\n    return this._validatorOptions as ValidatorOptions;\n  }\n\n  // Helpers\n  protected onlyFields(fields: FormModel<any>): Dictionary {\n    const newFields: Dictionary = {};\n\n    if (fields !== undefined) {\n      Object.keys(fields).forEach(key => {\n        if (fields[key] instanceof DynamicFormGroup) {\n          // Group: recursive\n          newFields[key] = this.onlyFields(\n            (fields[key] as DynamicFormGroup<any>).formFields\n          );\n        } else {\n          // Array\n          if (fields[key] instanceof FormArray) {\n            if (\n              (fields[key] as FormArray).controls[0] instanceof DynamicFormGroup\n            ) {\n              // Group within Array: recursive\n              newFields[key] = this.onlyFields(\n                ((fields[key] as FormArray).controls[0] as DynamicFormGroup<\n                  any\n                >).formFields\n              );\n            } else {\n              // Control within Array\n              newFields[key] = (fields[key] as FormArray).controls[0].value;\n            }\n          } else {\n            // Handle Control\n            newFields[key] = fields[key];\n          }\n        }\n      });\n    }\n\n    return newFields;\n  }\n\n  transformValidationErrors(errors: ValidationError[]): ShortValidationErrors {\n    const customErrors: ShortValidationErrors = {};\n\n    errors.forEach((error: ValidationError) => {\n      if (error && error.constraints !== undefined) {\n        Object.keys(error.constraints).forEach((key: string) => {\n          if (!customErrors[error.property]) {\n            customErrors[error.property] = [];\n          }\n\n          if (\n            (customErrors[error.property] as string[]).indexOf(\n              error.constraints[key]\n            ) === -1\n          ) {\n            (customErrors[error.property] as string[]).push(\n              error.constraints[key]\n            );\n          }\n        });\n      }\n\n      if (error.children !== undefined && error.children.length) {\n        customErrors[error.property] = this.transformValidationErrors(\n          error.children\n        );\n      }\n    });\n\n    return customErrors;\n  }\n\n  protected mergeErrors(\n    externalErrors?: ShortValidationErrors,\n    validationErrors?: ShortValidationErrors\n  ) {\n    const clonedExternalErrors = cloneDeep(externalErrors);\n    return mergeWith(\n      clonedExternalErrors,\n      validationErrors,\n      (objValue, srcValue) => {\n        if (canMerge()) {\n          return objValue.concat(srcValue);\n        }\n\n        function canMerge() {\n          return (\n            Array.isArray(objValue) &&\n            Array.isArray(srcValue) &&\n            objValue.filter(objItem => srcValue.indexOf(objItem) !== -1)\n              .length === 0\n          );\n        }\n      }\n    );\n  }\n\n  protected markAsInvalidForExternalErrors(\n    errors: ShortValidationErrors,\n    controls?: Dictionary<AbstractControl>\n  ) {\n    if (!controls) {\n      controls = this.controls;\n    }\n    Object.keys(controls).forEach(field => {\n      const control = controls![field];\n\n      // Control\n      if (control instanceof FormControl) {\n        if (errors && errors[field]) {\n          control.setErrors({ externalError: true });\n        } else {\n          if (control.errors && control.errors.externalError === true) {\n            control.setErrors(null);\n          }\n        }\n      }\n      // Group\n      else if (control instanceof DynamicFormGroup) {\n        control.markAsInvalidForExternalErrors(\n          errors && errors[field]\n            ? (errors[field] as ShortValidationErrors)\n            : {}\n        );\n      }\n      // Array\n      else if (control instanceof FormArray) {\n        for (let i = 0; i < (control as FormArray).length; i++) {\n          // Control in Array\n          if (control[i] instanceof FormControl) {\n            if (errors && errors[i] && errors[i][field]) {\n              control[i].setErrors({ externalError: true });\n            } else if (\n              control[i].errors &&\n              control[i].errors.externalError === true\n            ) {\n              control[i].setErrors(null);\n            }\n          }\n          // Group in Array\n          else if (control[i] instanceof DynamicFormGroup) {\n            control[i].markAsInvalidForExternalErrors(\n              errors && errors[i] && errors[i][field]\n                ? (errors[i][field] as ShortValidationErrors)\n                : {}\n            );\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Recursively gets all values from the form controls and all sub form group and array controls and returns it as\n   * an object\n   */\n  protected getObject(): TModel {\n    // Initialize the shape of the response\n    const object = this._object\n      ? this.classToClass(this._object)\n      : this.factoryModel\n      ? new this.factoryModel()\n      : undefined;\n\n    if (object !== undefined) {\n      // Recursively get the value of all fields\n      Object.keys(this.controls)\n        .filter(name => name !== FOREVER_INVALID_NAME)\n        .forEach(key => {\n          // Handle Group\n          if (this.controls[key] instanceof DynamicFormGroup) {\n            object[key] = (this.controls[key] as DynamicFormGroup<any>).object;\n          }\n\n          // Handle Form Array\n          else if (this.controls[key] instanceof FormArray) {\n            // Initialize value\n            object[key] = [];\n\n            for (\n              let i = 0;\n              i < (this.controls[key] as FormArray).controls.length;\n              i++\n            ) {\n              let value;\n\n              if (\n                (this.controls[key] as FormArray).controls[i] instanceof\n                DynamicFormGroup\n              ) {\n                // Recursively get object group\n                value = ((this.controls[key] as FormArray).controls[\n                  i\n                ] as DynamicFormGroup<any>).object;\n              } else {\n                value = (this.controls[key] as FormArray).controls[i].value;\n              }\n              if (value && Object.keys(value).length > 0) {\n                object[key].push(value);\n              }\n            }\n          }\n\n          // Handle Control\n          else {\n            object[key] = this.controls[key].value;\n          }\n        });\n    }\n    return (this.factoryModel\n      ? this.plainToClass(this.factoryModel, object)\n      : object) as TModel;\n  }\n\n  /**\n   * Sets the value of every control on the form and recursively sets the values of the controls\n   * on all sub form groups\n   *\n   * @param object the data to assign to all controls of the form group and sub groups\n   */\n  protected setObject(object: TModel) {\n    if (object instanceof this.factoryModel) {\n      this._object = this.classToClass(object); // Ensure correct type\n    } else {\n      this._object = this.plainToClass(this.factoryModel, object as Object); // Convert to Model type\n    }\n\n    // Recursively set the value of all fields\n    Object.keys(this.controls).forEach(key => {\n      // Handle Group\n      if (this.controls[key] instanceof DynamicFormGroup) {\n        (this.controls[key] as DynamicFormGroup<any>).object = this._object\n          ? this._object[key]\n          : {};\n      }\n\n      // Handle FormArray\n      else if (this.controls[key] instanceof FormArray) {\n        const objectArray = this._object ? this._object[key] : [];\n        const formArray = this.controls[key] as FormArray;\n        const isFormGroup = formArray.controls[0] instanceof DynamicFormGroup;\n        const firstFormGroup = formArray.controls[0] as DynamicFormGroup<any>;\n        const formControl = formArray.controls[0] as FormControl;\n\n        // Clear FormArray while retaining the reference\n        while (formArray.length !== 0) {\n          formArray.removeAt(0);\n        }\n\n        for (let i = 0; i < objectArray.length; i++) {\n          if (isFormGroup) {\n            // Create FormGroup\n            const dynamicFormGroup = new DynamicFormGroup(\n              firstFormGroup.factoryModel,\n              firstFormGroup.formFields\n            );\n\n            dynamicFormGroup.setParent(this);\n\n            const classValidators = getClassValidators<TModel>(\n              firstFormGroup.factoryModel,\n              firstFormGroup.formFields,\n              undefined,\n              this.FormControlClass\n            );\n            const formGroup = this._fb.group(classValidators);\n\n            // Add all controls to the form group\n            Object.keys(formGroup.controls).forEach(ctrlKey => {\n              dynamicFormGroup.addControl(ctrlKey, formGroup.controls[ctrlKey]);\n            });\n\n            // Add a value change listener to the group. on change, validate\n            dynamicFormGroup.valueChanges.subscribe(data => {\n              dynamicFormGroup.validate(undefined, this._validatorOptions as ValidatorOptions);\n            });\n\n            formArray.controls.push(dynamicFormGroup);\n\n            // Recusrively set the object value\n            (formArray.controls[i] as DynamicFormGroup<any>).object =\n              this._object && objectArray && objectArray[i]\n                ? objectArray[i]\n                : {};\n          } else {\n            // Create control\n            const controlValue =\n              this._object && objectArray && objectArray[i]\n                ? objectArray[i]\n                : undefined;\n            const newFormControl = new FormControl(\n              controlValue,\n              formControl.validator\n            );\n            newFormControl.setParent(this);\n\n            // Add the control to the FormArray\n            formArray.controls.push(newFormControl);\n          }\n        }\n      }\n\n      // Handle Control\n      else {\n        const newObject = this._object ? this._object[key] : [];\n        this.controls[key].setValue(\n          this._object && newObject ? newObject : undefined\n        );\n      }\n    });\n    this.objectChange.next(this._object);\n  }\n}\n\nexport function getClassValidators<TModel>(\n  factoryModel: ClassType<TModel>,\n  fields: Dictionary,\n  validatorOptions?: ValidatorOptions,\n  FormControlClass: any = DynamicFormControl\n) {\n  // Get the validation rules from the object decorators\n  const allValidationMetadatas: ValidationMetadata[] = getFromContainer(\n    MetadataStorage\n  ).getTargetValidationMetadatas(factoryModel, '');\n\n  // Get the validation rules for the validation group: https://github.com/typestack/class-validator#validation-groups\n  const validationGroupMetadatas: ValidationMetadata[] = getFromContainer(\n    MetadataStorage\n  ).getTargetValidationMetadatas(\n    factoryModel,\n    '',\n    validatorOptions && validatorOptions.groups\n      ? validatorOptions.groups\n      : undefined\n  );\n\n  const formGroupFields = {};\n  const validator = new Validator();\n\n  // Loop through all fields in the form definition\n  Object.keys(fields)\n    .filter(key => key.indexOf('__') !== 0)\n    .forEach(fieldName => {\n      // Conditional Validation for the field\n      const conditionalValidations: ValidationMetadata[] = [];\n      validationGroupMetadatas.forEach(validationMetadata => {\n        if (\n          isPropertyValidatorOfType(\n            validationMetadata,\n            fieldName,\n            ValidationKeys.conditional.type\n          )\n        ) {\n          conditionalValidations.push(validationMetadata);\n        }\n      });\n\n      // All Nested Validation for the field\n      const allNestedValidations: ValidationMetadata[] = [];\n      allValidationMetadatas.forEach(validationMetadata => {\n        if (\n          isPropertyValidatorOfType(\n            validationMetadata,\n            fieldName,\n            ValidationKeys.nested.type\n          )\n        ) {\n          allNestedValidations.push(validationMetadata);\n        }\n      });\n\n      // Nested Validation for the field for the requested class-validator group\n      const nestedGroupValidations: ValidationMetadata[] = [];\n      validationGroupMetadatas.forEach(validationMetadata => {\n        if (\n          isPropertyValidatorOfType(\n            validationMetadata,\n            fieldName,\n            ValidationKeys.nested.type\n          )\n        ) {\n          nestedGroupValidations.push(validationMetadata);\n        }\n      });\n\n      const fieldDefinition: DynamicFormGroupField = {\n        data: formGroupFields[fieldName],\n        validationFunctions: [],\n        validationDefinitions: []\n      };\n\n      if (fieldDefinition.data === undefined) {\n        fieldDefinition.data = fields[fieldName];\n      }\n      // TRY LINK EXISTS NATIVE VALIDATIONS, UNSTABLE !!!\n      if (\n        Array.isArray(fieldDefinition.data) &&\n        fieldDefinition.data.length > 1 &&\n        fieldDefinition.data.filter(\n          (validationFunction, index) =>\n            index > 0 && typeof validationFunction === 'function'\n        ).length > 0\n      ) {\n        fieldDefinition.data\n          .filter(\n            (validationFunction, index) =>\n              index > 0 && typeof validationFunction === 'function'\n          )\n          .forEach(validationFunction =>\n            fieldDefinition.validationFunctions.push(validationFunction)\n          );\n        fieldDefinition.data = fieldDefinition.data[0];\n      }\n\n      validationGroupMetadatas.forEach(validationMetadata => {\n        if (\n          validationMetadata.propertyName === fieldName &&\n          validationMetadata.type !== ValidationKeys.conditional.type\n        ) {\n          // Add all validation to the field except the @NestedValidation definition as\n          // being part of the form would imply it is validated if any other rules are present\n          if (validationMetadata.type !== ValidationKeys.nested.type) {\n            fieldDefinition.validationDefinitions.push(validationMetadata);\n          }\n\n          for (const typeKey in ValidationTypes) {\n            if (ValidationTypes.hasOwnProperty(typeKey)) {\n              // Handle Nested Validation\n              if (\n                checkWithAllNestedValidations(\n                  allNestedValidations,\n                  nestedGroupValidations,\n                  fieldName\n                )\n              ) {\n                if (isNestedValidate(validationMetadata, typeKey)) {\n                  const objectToValidate =\n                    fields[fieldName] instanceof DynamicFormGroup\n                      ? fields[fieldName].object\n                      : undefined;\n                  const nestedValidate = createNestedValidate(\n                    objectToValidate,\n                    validationMetadata\n                  );\n                  setFieldData(fieldName, fieldDefinition, nestedValidate);\n                }\n              }\n\n              // Handle Custom Validation\n              if (isCustomValidate(validationMetadata, typeKey)) {\n                const customValidation = createCustomValidation(\n                  fieldName,\n                  validationMetadata\n                );\n                setFieldData(fieldName, fieldDefinition, customValidation);\n              }\n\n              // Handle remaining validation\n              if (isDynamicValidate(validationMetadata, typeKey)) {\n                const dynamicValidate = createDynamicValidate(\n                  validationMetadata,\n                  conditionalValidations,\n                  fieldName\n                );\n                setFieldData(fieldName, fieldDefinition, dynamicValidate);\n              }\n            }\n          }\n        }\n      });\n      // Convert to a structure, angular understands\n      if (\n        fieldDefinition.data instanceof DynamicFormGroup ||\n        fieldDefinition.data instanceof FormArray\n      ) {\n        formGroupFields[fieldName] = fieldDefinition.data;\n      } else {\n        formGroupFields[fieldName] = new FormControlClass(fieldDefinition);\n      }\n    });\n\n  return formGroupFields;\n\n  // ******************************************************************************************\n  // Local Helper functions to help make the main code more readable\n  //\n\n  function createNestedValidate(\n    objectToValidate: any,\n    validationMetadata: ValidationMetadata\n  ) {\n    return function(control: FormControl) {\n      const isValid =\n        getValidateErrors(\n          control,\n          objectToValidate !== undefined ? objectToValidate : control.value,\n          validatorOptions as ValidatorOptions\n        ).length === 0;\n      return getIsValidResult(isValid, validationMetadata, 'nestedValidate');\n    };\n  }\n\n  function createDynamicValidate(\n    validationMetadata: ValidationMetadata,\n    conditionalValidations: ValidationMetadata[],\n    fieldName: string\n  ) {\n    return function(control: FormControl) {\n      if (!control) {\n        return null;\n      }\n\n      let isValid =\n        control.parent && control.parent.value\n          ? validator.validateValueByMetadata(control.value, validationMetadata)\n          : true;\n\n      if (!isValid && conditionalValidations.length > 0) {\n        const validateErrors = setObjectValueAndGetValidationErrors(\n          control,\n          fieldName,\n          validatorOptions as ValidatorOptions\n        );\n        isValid =\n          validateErrors.filter(\n            (error: ValidationError) => error.property === fieldName\n          ).length === 0;\n      }\n\n      return getIsValidResult(isValid, validationMetadata, 'dynamicValidate');\n    };\n  }\n\n  function createCustomValidation(\n    fieldName: string,\n    validationMetadata: ValidationMetadata\n  ) {\n    return function(control: FormControl) {\n      const validateErrors: ValidationError[] = setObjectValueAndGetValidationErrors(\n        control,\n        fieldName,\n        validatorOptions as ValidatorOptions\n      );\n      const isValid = getAllErrors(validateErrors, fieldName).length === 0;\n      return getIsValidResult(isValid, validationMetadata, 'customValidation');\n    };\n  }\n\n  function checkWithAllNestedValidations(\n    allNestedValidations: ValidationMetadata[],\n    nestedValidations: ValidationMetadata[],\n    key: string\n  ) {\n    return (\n      allNestedValidations.length === nestedValidations.length ||\n      ((fields[key] instanceof DynamicFormGroup ||\n        fields[key] instanceof FormArray) &&\n        allNestedValidations.length > 0 && nestedValidations.length === 0)\n    );\n  }\n\n  function isDynamicValidate(\n    validationMetadata: ValidationMetadata,\n    typeKey: string\n  ) {\n    return (\n      validationMetadata.type === ValidationTypes[typeKey] &&\n      validator[validationMetadata.type] !== undefined\n    );\n  }\n\n  /**\n   * marked with @Validate(...)\n   * https://github.com/typestack/class-validator#custom-validation-classes\n   */\n  function isCustomValidate(\n    validationMetadata: ValidationMetadata,\n    typeKey: string\n  ) {\n    return (\n      isNotPropertyValidation(validationMetadata, typeKey) &&\n      validationMetadata.type === ValidationKeys.custom.type &&\n      typeKey === ValidationKeys.custom.typeKey\n    );\n  }\n\n  /**\n   * marked with @ValidateNested()\n   * https://github.com/typestack/class-validator#validating-nested-objects\n   */\n  function isNestedValidate(\n    validationMetadata: ValidationMetadata,\n    typeKey: string\n  ) {\n    return (\n      isNotPropertyValidation(validationMetadata, typeKey) &&\n      validationMetadata.type === ValidationKeys.nested.type &&\n      typeKey === ValidationKeys.nested.typeKey\n    );\n  }\n\n  function isNotPropertyValidation(\n    validationMetadata: ValidationMetadata,\n    typeKey: string\n  ) {\n    return (\n      validationMetadata.type === ValidationTypes[typeKey] &&\n      validator[validationMetadata.type] === undefined\n    );\n  }\n\n  function setFieldData(\n    fieldName: string,\n    fieldDefinition: DynamicFormGroupField,\n    validationFunction: Function\n  ) {\n    /* todo: maybe not need, if enable this code, experemental mode not work\n    if (fields[fieldName] instanceof DynamicFormGroup) {\n      fields[fieldName].object = fields[fieldName].fields;\n    }*/\n\n    // Fill field data if empty\n    if (fieldDefinition.data === undefined) {\n      fieldDefinition.data = fields[fieldName];\n    }\n\n    fieldDefinition.validationFunctions.push(validationFunction);\n  }\n\n  function getAllErrors(\n    validateErrors: ValidationError[],\n    fieldName: string\n  ): ValidationError[] {\n    return validateErrors.filter(\n      (error: ValidationError) =>\n        // Check for nested/child errors\n        (error.children.length &&\n          error.children.filter(children => children.property === fieldName)) ||\n        error.property === fieldName\n    );\n  }\n}\n\n// ***************************************************************\n// Global Helper functions\n//\n\nfunction isPropertyValidatorOfType(\n  validationMetadata: ValidationMetadata,\n  fieldName: string,\n  validationMetadataType: string\n) {\n  return (\n    validationMetadata.propertyName === fieldName &&\n    validationMetadata.type === validationMetadataType\n  );\n}\n\nfunction setObjectValueAndGetValidationErrors(\n  control: FormControl,\n  key: string,\n  validatorOptions: ValidatorOptions\n) {\n  const object =\n    control.parent instanceof DynamicFormGroup\n      ? (control.parent as DynamicFormGroup<any>).object\n      : control.parent\n      ? control.parent.value\n      : {};\n\n  if (object) {\n    object[key] = control.value;\n  }\n\n  return getValidateErrors(control, object, validatorOptions);\n}\n\nfunction getValidateErrors(\n  control: FormControl,\n  dataToValidate: any,\n  validatorOptions: ValidatorOptions\n) {\n  const validateErrors: ValidationError[] =\n    control.parent && control.parent.value\n      ? validateSync(dataToValidate, validatorOptions)\n      : [];\n  return validateErrors;\n}\n\nfunction getIsValidResult(\n  isValid: boolean,\n  validationMetadata: ValidationMetadata,\n  errorType: ErrorPropertyName\n) {\n  return isValid\n    ? null\n    : {\n        [errorType]: {\n          valid: false,\n          type: validationMetadata.type\n        }\n      };\n}\n\ntype ErrorPropertyName =\n  | 'nestedValidate'\n  | 'customValidation'\n  | 'dynamicValidate';\n\nconst ValidationKeys = {\n  nested: {\n    type: 'nestedValidation',\n    typeKey: 'NESTED_VALIDATION'\n  },\n  conditional: {\n    type: 'conditionalValidation'\n  },\n  custom: {\n    type: 'customValidation',\n    typeKey: 'CUSTOM_VALIDATION'\n  }\n};\n","import 'reflect-metadata';\n\nimport { AbstractControlOptions, FormBuilder, ValidatorFn } from '@angular/forms';\nimport { plainToClass } from 'class-transformer';\nimport { ClassType } from 'class-transformer/ClassTransformer';\n\nimport {\n  DynamicFormGroupConfig,\n  isAbstractControlOptions,\n  isDynamicFormGroupConfig,\n  isLegacyOrOpts\n} from '../models/dynamic-form-group-config';\nimport { DynamicFormGroup, FormModel, getClassValidators } from './dynamic-form-group';\nimport { DynamicFormControl } from './dynamic-form-control';\nimport { DynamicForm } from '@libertyware/ngx-form-core';\n\nexport class DynamicFormBuilder extends FormBuilder {\n\n  protected FormGroupClass = DynamicFormGroup;\n  protected FormControlClass = DynamicFormControl;\n  group<TModel>(\n    factoryModel: ClassType<TModel>,\n    controlsConfig?:\n      | FormModel<TModel>\n      | DynamicFormGroupConfig\n      | { [key: string]: any },\n    options?: AbstractControlOptions | DynamicFormGroupConfig\n  ): DynamicFormGroup<TModel> {\n    // Process the group with the controlsConfig passed into extra instead. (What does this accomplish?)\n    if (\n      controlsConfig &&\n      (isAbstractControlOptions(controlsConfig) ||\n        isLegacyOrOpts(controlsConfig) ||\n        isDynamicFormGroupConfig(controlsConfig)) &&\n      !options\n    ) {\n      return this.group(factoryModel, undefined, controlsConfig);\n    }\n\n    // This section of code was added in from the original code - Jordan\n    if (!controlsConfig) {\n      const model = (new factoryModel() as unknown) as DynamicForm;\n      const fields = model.getFormFields();\n      controlsConfig = {\n        ...((fields\n          .map((field: any) => ({\n            [field.fieldName]: ''\n          }))\n          .reduce(\n            (rev: any, current: any) => ({ ...rev, ...current }),\n            {}\n          ) as unknown) as FormModel<TModel>)\n      };\n    }\n\n    const extra: DynamicFormGroupConfig = options as DynamicFormGroupConfig;\n\n    let validators: ValidatorFn[] | null = null;\n    let asyncValidators: ValidatorFn[]  | null = null;\n    let updateOn: any;\n\n    if (extra != null) {\n      if (isAbstractControlOptions(extra)) {\n        // `extra` are `AbstractControlOptions`\n        validators = extra.validators != null ? extra.validators : null;\n        asyncValidators = extra.asyncValidators != null ? extra.asyncValidators : null;\n        updateOn = extra.updateOn != null ? extra.updateOn : undefined;\n      }\n      if (isLegacyOrOpts(extra)) {\n        // `extra` are legacy form group options\n        validators = validators || [];\n        if (extra.validator) validators.push(extra.validator);\n\n        asyncValidators = asyncValidators || [];\n        if (extra.asyncValidator) validators.push(extra.asyncValidator);\n      }\n      // Set default customValidatorOptions\n      if (!isDynamicFormGroupConfig(extra)) {\n        extra.customValidatorOptions = { validationError: { target: false } };\n      }\n    }\n\n    let newControlsConfig: FormModel<TModel> | any;\n\n    if (controlsConfig !== undefined) {\n      newControlsConfig = controlsConfig as FormModel<TModel>;\n    }\n\n    // experimental\n    if (controlsConfig === undefined) {\n      newControlsConfig = { ...this.createEmptyObject(factoryModel) };\n\n      Object.keys(newControlsConfig).forEach(key => {\n        if (canCreateGroup()) {\n          // recursively create a dynamic group for the nested object\n          newControlsConfig[key] = this.group(\n            newControlsConfig[key].constructor,\n            undefined,\n            {\n              ...(extra.customValidatorOptions\n                ? { customValidatorOptions: extra.customValidatorOptions }\n                : {}),\n              asyncValidators,\n              updateOn,\n              validators\n            } as any\n          );\n        } else {\n          if (canCreateArray()) {\n            if (newControlsConfig[key][0].constructor) {\n              // recursively create an array with a group\n              newControlsConfig[key] = super.array(\n                newControlsConfig[key].map((newControlsConfigItem: any) =>\n                  this.group(newControlsConfigItem.constructor, undefined, {\n                    ...(extra.customValidatorOptions\n                      ? { customValidatorOptions: extra.customValidatorOptions }\n                      : {}),\n                    asyncValidators,\n                    updateOn,\n                    validators\n                  } as any)\n                )\n              );\n            } else {\n              // Create an array of form controls\n              newControlsConfig[key] = super.array(\n                newControlsConfig[key].map((newControlsConfigItem: any) =>\n                  this.control(newControlsConfigItem)\n                )\n              );\n            }\n          }\n        }\n\n        function canCreateGroup() {\n          const candidate = newControlsConfig[key];\n\n          return (\n            candidate &&\n            !Array.isArray(candidate) &&\n            candidate.constructor &&\n            typeof candidate === 'object' &&\n            (candidate.length === undefined ||\n              (candidate.length !== undefined &&\n                Object.keys(candidate).length === candidate.length))\n          );\n        }\n\n        function canCreateArray() {\n          if (Array.isArray(newControlsConfig[key]) === false) {\n            return false;\n          }\n\n          const candidate = newControlsConfig[key][0];\n\n          return (\n            candidate.constructor &&\n            typeof candidate === 'object' &&\n            (candidate.length === undefined ||\n              (candidate.length !== undefined &&\n                Object.keys(candidate).length === candidate.length))\n          );\n        }\n      });\n    }\n\n    // Remove empty\n    validators = validators && validators.filter(validator => validator);\n    asyncValidators =\n      asyncValidators && asyncValidators.filter(validator => validator);\n\n    // Create an Angular group from the top-level object\n    const classValidators = getClassValidators<TModel>(\n      factoryModel,\n      newControlsConfig,\n      extra && extra.customValidatorOptions,\n      this.FormControlClass\n    );\n    const formGroup = super.group(classValidators, {\n      ...(asyncValidators || {}),\n      ...(updateOn || {}),\n      ...(validators || {})\n    });\n\n    // Initialize the resulting group\n    // Changed from internal FormGroup to DynamicFormGroup\n    const dynamicFormGroup = new DynamicFormGroup<TModel>(\n      factoryModel,\n      newControlsConfig,\n      {\n        asyncValidators,\n        updateOn,\n        validators\n      } as any\n    );\n\n    // Add all angular controls to the resulting dynamic group\n    Object.keys(formGroup.controls).forEach(key => {\n      dynamicFormGroup.addControl(key, formGroup.controls[key]);\n    });\n\n    // Add a listener to the dynamic group for value changes; on change, execute validation\n    dynamicFormGroup.valueChanges.subscribe(() => dynamicFormGroup.validate(undefined, extra && extra.customValidatorOptions));\n\n    return dynamicFormGroup;\n  }\n\n  // *******************\n  // Helpers\n\n  /**\n   * Recursively creates an empty object from the data provided\n   */\n  private createEmptyObject<TModel>(\n    factoryModel: ClassType<TModel>,\n    data: {[key: string]: any} = {}\n  ): any {\n    let modified = false;\n\n    const object: any = factoryModel ? plainToClass(factoryModel, data) : data;\n    const fields = Object.keys(object);\n\n    fields.forEach((fieldName: any) => {\n      if (object[fieldName] && object[fieldName].length !== undefined) {\n        if (\n          object[fieldName].length === 1 &&\n          Object.keys(object[fieldName][0]).length > 0 &&\n          object[fieldName][0].constructor\n        ) {\n          object[fieldName] = [\n            this.createEmptyObject(object[fieldName][0].constructor)\n          ];\n        }\n\n        if (object[fieldName].length === 0) {\n          data[fieldName] = [{}];\n          modified = true;\n        }\n      } else {\n        data[fieldName] = undefined;\n      }\n    });\n\n    if (modified) {\n      return this.createEmptyObject(factoryModel, data);\n    }\n\n    return object;\n  }\n}\n"]}